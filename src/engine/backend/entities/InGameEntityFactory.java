// This entire file is part of my masterpiece.
// Kushal Byatnal

/*
 * This code is used within the Engine during game play to create entities and display them on the screen. It is initialized by being passed
 * a list of authored entities (generated by the user when designing the game), from which it creates a map of String to Map. The first layer
 * of the Map categorizes entities by their "genre" and the second layer maps them from their name to the IEntity. 
 * 
 * Thus, the class contains a mapping of all of the entities created within the authoring environment and is crucial for running the game.
 * During gameplay, when the user drags a tower onto the Map or a bullet is fired or an enemy spawns, the createEntity() method is invoked. 
 * 
 *  I chose this code because it demonstrates a lot of what I've learned in this class about various features within Java and good coding 
 *  practices. Throughout this course, I've learned that having short, descriptive methods that do one thing and one thing only is key. That's
 *  why within this class, all of the methods are short and are named appropriately. The key method, createMao(), is broken up into 
 *  submethods which clearly state each action. findInMap is used to get the corresponding authored entity, and copyComponents / cloneComponent
 *  work together to populate a new entity from the template. The methods are have short, clear names and the variables within the methods
 *  are also appropriately named (ex. templateEntity vs. newEntity). In addition, another good practice is to have exception handling to deal
 *  with various issues that can arise during gameplay (an incorrect name was passed into the factory, for example). In these cases, custom
 *  DrumpfTowerExceptions are thrown. The messages have been removed from this class and stored within a separate class named 
 *  ExceptionTagResources. Finally, setters and getters are used (instead of simply making the variables public) when they need to be 
 *  referenced by outside classes.
 *  
 *  In terms of new features, this class demonstrates one of the coolest aspects of Java I've learned during this course. The clone component
 *  method, used to generate identical copies of the authored entities but with separate component objects, utilizes reflection to populate
 *  the objects. For each component within the template entity, the method invokes the specific constructor for that component and passes in 
 *  the component from the template. From here, the component populates itself according to the values stored within the template. This code 
 *  prevents using multiple switch/case statements or if/else statements (as I probably would have done before I knew anything about writing
 *  clean, maintainable code) and doesn't need to be updated when a new component class is added. 
 */

package engine.backend.entities;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import engine.backend.components.EmptyComponent;
import engine.backend.components.IComponent;
import engine.backend.utilities.ExceptionTagResources;
import exception.DrumpfTowerException;
import exception.ExceptionLoader;

public class InGameEntityFactory {

	private Map<String, Map<String, IEntity>> myEntityMap;
	private int currentLevelId;
	private int initNumEntities;
	private int nextAvailableID;
	private ExceptionLoader myExceptionLoader;

	public InGameEntityFactory(List<IEntity> entities) {
		myExceptionLoader = new ExceptionLoader();
		this.myEntityMap = createMap(entities);
		nextAvailableID = 0;
	}

	private Map<String, Map<String, IEntity>> createMap(List<IEntity> entities) {
		Map<String, Map<String, IEntity>> mainEntityMap = new HashMap<String, Map<String, IEntity>>();
		for (IEntity entity : entities) {
			Map<String, IEntity> typeMap = null;
			if (mainEntityMap.containsKey(entity.getGenre())) {
				typeMap = mainEntityMap.get(entity.getGenre());
			} else {
				typeMap = new HashMap<String, IEntity>();
				mainEntityMap.put(entity.getGenre(), typeMap);
			}
			typeMap.put(entity.getName(), entity);
		}
		return mainEntityMap;
	}

	/**
	 * 
	 * @param entityName
	 * @return A entity with the entity name given.
	 * @throws DrumpfTowerException 
	 */

	public IEntity createEntity(String entityName) throws DrumpfTowerException {
		IEntity templateEntity = findInMap(entityName);
		if (templateEntity == null)
			throw new DrumpfTowerException(myExceptionLoader.getString(ExceptionTagResources.ENTITY_DNE));

		IEntity newEntity = new Entity(initNumEntities + getNextAvailableID(), templateEntity.getName(),
				templateEntity.getGenre());
		copyComponents(newEntity, templateEntity);
		return newEntity;
	}

	private IEntity findInMap(String entityName) {
		for (String type : myEntityMap.keySet()) {
			Map<String, IEntity> entities = myEntityMap.get(type);
			if (entities.containsKey(entityName)) {
				return entities.get(entityName);
			}
		}
		return null;
	}

	private void copyComponents(IEntity newEntity, IEntity templateEntity) throws DrumpfTowerException {
		Collection<IComponent> templateComponents = templateEntity.getComponents();
		for (IComponent component : templateComponents) {
			IComponent copyComponent = cloneComponent(component);
			newEntity.addComponent(copyComponent);
		}
	}

	private IComponent cloneComponent(IComponent component) throws DrumpfTowerException {
		try {
			Constructor<? extends IComponent> constructor = component.getClass().getConstructor(component.getClass());
			return (IComponent) constructor.newInstance(component);
		} catch (InstantiationException e) {
			throw new DrumpfTowerException(myExceptionLoader.getString(ExceptionTagResources.INSTANTIATION));
		} catch (IllegalAccessException e) {
			throw new DrumpfTowerException(myExceptionLoader.getString(ExceptionTagResources.LACK_ACCESS));
		} catch (IllegalArgumentException e) {
			throw new DrumpfTowerException(myExceptionLoader.getString(ExceptionTagResources.ILLEGAL_ARGS));
		} catch (InvocationTargetException e) {
		} catch (NoSuchMethodException e1) {
			throw new DrumpfTowerException(myExceptionLoader.getString(ExceptionTagResources.METHOD_DNE));
		} catch (SecurityException e1) {
			throw new DrumpfTowerException(myExceptionLoader.getString(ExceptionTagResources.SECURITY_EXCEPTION));
		}
		return (IComponent) new EmptyComponent();
	}

	public boolean isCurrent(int id) {
		return this.currentLevelId == id;
	}

	public void setEntities(List<IEntity> entities) {
		this.myEntityMap = createMap(entities);
	}

	public void setID(int id) {
		this.currentLevelId = id;
	}

	public void setInitNumEntities(int num) {
		this.initNumEntities = num;
	}

	private int getNextAvailableID() {
		nextAvailableID++;
		return this.nextAvailableID;
	}

}
